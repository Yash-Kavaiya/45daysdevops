# Linux for DevOps - Day 1: Complete Fundamentals Guide

## üìö Table of Contents

1. [Course Overview](#course-overview)
2. [How Does the Internet Work?](#how-does-the-internet-work)
3. [Understanding Servers](#understanding-servers)
4. [Types of Servers](#types-of-servers)
5. [Server vs Client Architecture](#server-vs-client-architecture)
6. [Web Server vs Application Server](#web-server-vs-application-server)
7. [Types of Applications](#types-of-applications)
8. [Application Support and Maintenance](#application-support-and-maintenance)
9. [Introduction to Linux](#introduction-to-linux)
10. [Linux vs Windows Comparison](#linux-vs-windows-comparison)
11. [Linux vs Unix](#linux-vs-unix)
12. [How to Install Linux](#how-to-install-linux)
13. [Linux Core Components](#linux-core-components)
14. [Linux System Architecture](#linux-system-architecture)
15. [Linux File System Hierarchy](#linux-file-system-hierarchy)
16. [Hardware Information Commands](#hardware-information-commands)
17. [Process States in Linux](#process-states-in-linux)
18. [Remote Access Tools](#remote-access-tools)
19. [Setting Up Linux on AWS EC2](#setting-up-linux-on-aws-ec2)
20. [Key Interview Questions](#key-interview-questions)

---

## Course Overview

This course covers Linux fundamentals essential for DevOps Engineers, including:

```mermaid
mindmap
  root((Linux for DevOps))
    Internet & Servers
      How Internet Works
      Server Types
      Client-Server Model
    Linux Fundamentals
      What is Linux OS
      Linux Installation
      Kernel, Shell, Bootloader
    System Administration
      File Management
      User & Group Management
      Volume Management
    Commands
      Basic Commands
      Advanced Commands
      Pro Commands (AWK, GREP, FIND, SED)
    Networking
      Networking Commands
      File Transfer Commands
      Remote Access Tools
```

---

## How Does the Internet Work?

### Definition

> **Internet** is a global network of interconnected computers that communicate through standardized protocols, primarily using **fiber optic cables** laid across ocean floors to connect data centers worldwide.

### The Misconception vs Reality

| Common Misconception | Reality |
|---------------------|---------|
| Data travels via satellites | Data primarily travels through **fiber optic cables** under the ocean |
| Satellites provide internet | Satellites are too slow due to distance (used only in remote areas) |
| Data is transmitted wirelessly across continents | Undersea cables connect continents for faster transmission |

### How Data Travels

```mermaid
flowchart LR
    subgraph Your_Location["Your Location (India)"]
        A[Your Device]
    end
    
    subgraph ISP["Internet Service Provider"]
        B[Jio/Airtel Router]
    end
    
    subgraph Ocean["Undersea Cables"]
        C[Fiber Optic Cables]
    end
    
    subgraph Data_Center["Data Center (USA)"]
        D[YouTube Servers]
    end
    
    A -->|Request| B
    B -->|Through| C
    C -->|To| D
    D -->|Response| C
    C -->|Through| B
    B -->|To| A
    
    style C fill:#0077be
    style D fill:#ff0000
```

### Key Components of Internet Infrastructure

| Component | Description | Example |
|-----------|-------------|---------|
| **Fiber Optic Cables** | Physical cables laid under the ocean floor that carry data as light signals | Jio's submarine cables |
| **Data Centers** | Large facilities housing thousands of computers (servers) that store and serve data | Google Data Center, AWS Data Center |
| **ISP (Internet Service Provider)** | Companies that provide internet access to end users | Jio, Airtel, BSNL, ACT Broadband |
| **Routers** | Devices that direct data packets between networks | Home WiFi router |

### Why Fiber Optic Cables Instead of Satellites?

| Factor | Fiber Optic Cables | Satellites |
|--------|-------------------|------------|
| **Speed** | Very fast (light travels through fiber) | Slow due to distance |
| **Latency** | Low latency (~50-100ms) | High latency (~600ms+) |
| **Reliability** | Highly reliable | Weather dependent |
| **Bandwidth** | Very high | Limited |
| **Use Case** | Primary internet infrastructure | Remote/rural areas only |

### Who Owns These Cables?

Major companies that own undersea fiber optic cables include:
- **AT&T** (USA)
- **Reliance Jio** (India)
- **Google** (owns significant portions)
- **Facebook/Meta** (owns significant portions)
- **China Telecom**

> **üí° Key Point:** When you pay for "internet recharge" or "data pack," you're essentially paying these companies for access to use their cables to reach data centers.

---

## Understanding Servers

### Definition

> **Server** is a computer (or a program) whose primary purpose is to **serve information** to other computers (clients). It's called a "server" because it serves data/services to those who request it.

### Simple Analogy

Think of a server like a **waiter in a restaurant**:
- The waiter (server) **serves** food (data) to customers (clients)
- The waiter takes your **request** (order)
- The waiter brings back the **response** (food)

### Visual Representation

```mermaid
flowchart TD
    subgraph Server_Machine["Server (Data Center)"]
        S[("Server Computer")]
    end
    
    subgraph Clients["Clients"]
        C1[üì± Mobile Phone]
        C2[üíª Laptop]
        C3[üñ•Ô∏è Desktop]
        C4[üì∫ Smart TV]
    end
    
    C1 -->|Request| S
    C2 -->|Request| S
    C3 -->|Request| S
    C4 -->|Request| S
    
    S -->|Response| C1
    S -->|Response| C2
    S -->|Response| C3
    S -->|Response| C4
    
    style S fill:#4CAF50
```

---

## Types of Servers

Different servers are categorized based on the type of service they provide:

```mermaid
flowchart TB
    subgraph Server_Types["Types of Servers"]
        direction TB
        WS["üåê Web Server"]
        ES["üìß Email Server"]
        FS["üìÅ File Server"]
        DS["üóÑÔ∏è Database Server"]
        AS["‚öôÔ∏è Application Server"]
        DNS["üîó DNS Server"]
    end
    
    WS --- |"Serves static content<br>(HTML, CSS, Images)"| WS_DESC["Example: Nginx, Apache"]
    ES --- |"Handles email<br>sending/receiving"| ES_DESC["Example: Gmail Server"]
    FS --- |"Stores and serves<br>files"| FS_DESC["Example: NAS, FTP Server"]
    DS --- |"Stores and manages<br>database data"| DS_DESC["Example: MySQL, PostgreSQL"]
    AS --- |"Runs applications<br>(Dynamic content)"| AS_DESC["Example: Django, Node.js"]
    DNS --- |"Translates domain names<br>to IP addresses"| DNS_DESC["Example: 8.8.8.8"]
```

### Detailed Server Types Table

| Server Type | Primary Function | What it Serves | Examples |
|-------------|-----------------|----------------|----------|
| **Web Server** | Serve static web content | HTML pages, CSS, JavaScript, Images | Nginx, Apache HTTP Server |
| **Email Server** | Handle email communications | Send and receive emails | Gmail Server, Microsoft Exchange |
| **File Server** | Store and share files | Documents, media files | FTP Server, NAS |
| **Database Server** | Store and manage data | Structured data (tables, records) | MySQL, PostgreSQL, MongoDB |
| **Application Server** | Run application logic | Dynamic content, computations | Django, Node.js, Tomcat |
| **DNS Server** | Resolve domain names | IP addresses for domain names | Google DNS (8.8.8.8), Cloudflare (1.1.1.1) |

---

## Server vs Client Architecture

### Key Definitions

| Term | Definition | Role |
|------|------------|------|
| **Server** | A computer that provides resources/services | **To SERVE** information |
| **Client** | A computer/device that requests resources/services | **To REQUEST** information |

### The Relationship

```mermaid
sequenceDiagram
    participant Client as üë§ Client (Browser)
    participant DNS as üîó DNS Server
    participant Server as üñ•Ô∏è Web Server
    
    Client->>DNS: What is the IP of youtube.com?
    DNS-->>Client: IP: 172.217.14.110
    Client->>Server: Request: Get youtube.com homepage
    Server-->>Client: Response: HTML, CSS, JS, Images
    
    Note over Client,Server: This request-response cycle<br/>is the foundation of the internet
```

### What Can Be a Client?

| Device | How it Acts as Client |
|--------|----------------------|
| **Mobile Phone** | Uses browser/apps to request data from servers |
| **Laptop/Desktop** | Uses browser to access websites |
| **Smart TV** | Streams content from Netflix/YouTube servers |
| **IoT Devices** | Request/send data to cloud servers |
| **Another Server** | When one server requests data from another |

---

## Web Server vs Application Server

This is a **common interview question** for DevOps engineers.

### Comparison Table

| Aspect | Web Server | Application Server |
|--------|------------|-------------------|
| **Primary Purpose** | Serve **static** content | Serve **dynamic** content |
| **Content Type** | HTML, CSS, Images, JavaScript files | Computed results, API responses |
| **Processing** | Minimal processing | Heavy business logic processing |
| **Examples** | Nginx, Apache HTTP Server | Django, Node.js, Tomcat, Flask |
| **Use Case** | Hosting static websites, serving files | Running web applications with logic |
| **Database Interaction** | Usually none | Frequently interacts with databases |

### Visual Comparison

```mermaid
flowchart LR
    subgraph Static["Static Content Flow"]
        C1[Client] -->|Request: logo.png| WS[Web Server]
        WS -->|Response: Image File| C1
    end
    
    subgraph Dynamic["Dynamic Content Flow"]
        C2[Client] -->|Request: Get User Profile| AS[Application Server]
        AS -->|Query| DB[(Database)]
        DB -->|Data| AS
        AS -->|Computed Response| C2
    end
    
    style WS fill:#2196F3
    style AS fill:#FF9800
    style DB fill:#4CAF50
```

### Key Differences Explained

| Feature | Web Server | Application Server |
|---------|------------|-------------------|
| **Data Type** | Static (doesn't change) | Dynamic (computed on request) |
| **Computation** | No/minimal computation | Heavy computation & business logic |
| **Caching** | Highly cacheable | Often not cacheable |
| **Scalability** | Easy to scale horizontally | More complex scaling requirements |
| **Resource Usage** | Low CPU, low memory | High CPU, high memory |

### Real-World Example

```mermaid
flowchart TB
    subgraph YouTube_Architecture["YouTube Architecture (Simplified)"]
        Client[üì± Your Browser]
        
        subgraph Web_Layer["Web Server Layer"]
            WS[Nginx<br/>Serves: Logo, CSS, JS]
        end
        
        subgraph App_Layer["Application Server Layer"]
            AS[Application Server<br/>Serves: Video recommendations,<br/>comments, user data]
        end
        
        subgraph Data_Layer["Data Layer"]
            DB[(Database<br/>User data, comments)]
            CDN[CDN<br/>Video files]
        end
        
        Client --> WS
        Client --> AS
        WS --> CDN
        AS --> DB
    end
    
    style WS fill:#2196F3
    style AS fill:#FF9800
    style DB fill:#4CAF50
    style CDN fill:#9C27B0
```

---

## Types of Applications

There are two main types of applications:

### 1. Standalone Applications

> **Definition:** Applications that work independently without needing internet connectivity or external services.

| Characteristic | Description |
|---------------|-------------|
| **Internet Required** | No |
| **External Dependencies** | None or minimal |
| **Database Connection** | Usually local or none |
| **Examples** | Calculator, Notepad, Airport feedback kiosks, Vending machines |

### 2. Web Applications

> **Definition:** Applications that run on the internet and depend on multiple servers and services to function.

| Characteristic | Description |
|---------------|-------------|
| **Internet Required** | Yes |
| **External Dependencies** | Many (databases, APIs, email servers, etc.) |
| **Database Connection** | Remote database servers |
| **Examples** | YouTube, Instagram, Facebook, Gmail |

### Comparison Diagram

```mermaid
flowchart TB
    subgraph Standalone["Standalone Application"]
        direction TB
        SA[Application]
        SA --> LDB[(Local Storage)]
        Note1[No internet needed<br/>Works independently]
    end
    
    subgraph Web["Web Application"]
        direction TB
        WA[Web Application]
        WA --> ES[üìß Email Server]
        WA --> DS[(Database Server)]
        WA --> AS[API Services]
        WA --> CS[Cache Server]
        WA --> CDN[CDN]
        Note2[Requires internet<br/>Multiple dependencies]
    end
    
    style SA fill:#4CAF50
    style WA fill:#2196F3
```

### Comparison Table

| Feature | Standalone Application | Web Application |
|---------|----------------------|-----------------|
| **Internet Dependency** | ‚ùå Not required | ‚úÖ Required |
| **Installation** | Installed locally | Accessed via browser |
| **Updates** | Manual updates | Automatic (server-side) |
| **Data Storage** | Local device | Remote servers |
| **DevOps Complexity** | Low | High |
| **Infrastructure Needed** | Minimal | Multiple servers, databases, CDNs |

### Why DevOps Engineers Need to Know This

As a DevOps engineer, understanding application types is crucial because:

| Application Type | DevOps Responsibilities |
|-----------------|------------------------|
| **Standalone** | Simple deployment, minimal monitoring |
| **Web Application** | Complex infrastructure, database connections, monitoring, scaling, multiple service coordination |

---

## Application Support and Maintenance

### Definition

> **Application Support & Maintenance** refers to the ongoing activities required to keep applications running smoothly, including monitoring, troubleshooting, and fixing issues.

### Key Responsibilities

```mermaid
flowchart TD
    subgraph Support["Application Support & Maintenance"]
        M[üîç Monitoring]
        T[üîß Troubleshooting]
        U[‚¨ÜÔ∏è Updates & Patches]
        P[üìà Performance Optimization]
        S[üîí Security Maintenance]
        B[üíæ Backup & Recovery]
    end
    
    M --> Issues[Identify Issues]
    T --> Fix[Fix Problems]
    U --> Stable[Keep System Stable]
    P --> Fast[Improve Speed]
    S --> Secure[Prevent Attacks]
    B --> Safe[Data Safety]
```

### Common Issues DevOps Engineers Handle

| Issue Type | Description | Example |
|------------|-------------|---------|
| **Connection Issues** | Server connections failing | Email server connection lost |
| **Performance Issues** | Slow response times | High CPU usage |
| **Crash Issues** | Application stops working | Memory leak causing crash |
| **Security Issues** | Vulnerabilities or attacks | DDoS attack, unauthorized access |
| **Scaling Issues** | Unable to handle load | Too many users causing slowdown |

---

## Introduction to Linux

### What is Linux?

> **Linux** is a free, open-source operating system kernel created by **Linus Torvalds** in **1991**. It's the foundation for numerous operating systems (called distributions) that run on everything from smartphones to supercomputers.

### The Name Origin

```
Linus + Unix = Linux
 ‚Üì        ‚Üì
Creator  Inspiration
```

**Linus Torvalds** combined his first name with "Unix" (the OS that inspired Linux) to create the name "Linux."

### Key Statistics

| Statistic | Value |
|-----------|-------|
| **Desktop Users** | ~2-3% of personal computers |
| **Server Market** | ~90%+ of all servers |
| **Supercomputers** | 100% of top 500 supercomputers |
| **Mobile (Android)** | ~70% of smartphones (Android uses Linux kernel) |
| **Cloud Infrastructure** | ~90%+ of cloud servers |

### Why Linux Dominates Servers

```mermaid
pie title Server Operating System Usage
    "Linux" : 90
    "Windows Server" : 8
    "Others" : 2
```

### Key Advantages of Linux

| Advantage | Description |
|-----------|-------------|
| **üÜì Free & Open Source** | No licensing costs, source code available |
| **üîí Security** | More secure, fewer viruses, no antivirus needed |
| **üéØ Stability** | Rarely crashes, high uptime |
| **‚ö° Performance** | Efficient resource usage |
| **üîÑ No Forced Updates** | Updates when YOU decide, not mid-meeting! |
| **üõ†Ô∏è Customizable** | Complete control over the system |
| **üë• Community Support** | Large community for help and contributions |

### The Windows Update Problem (Humorous but True!)

```mermaid
flowchart LR
    subgraph Windows_Problem["Windows at Wrong Times"]
        W1[Important Meeting<br/>in 2 minutes] --> WU[Windows is<br/>Updating...]
        W2[Production Issue!<br/>Need to fix NOW] --> WU
        W3[Wedding Email<br/>to Send] --> WU
    end
    
    subgraph Linux_Solution["Linux Solution"]
        L1[Update when<br/>YOU want]
        L2[No forced<br/>restarts]
        L3[You're in<br/>control]
    end
    
    style WU fill:#ff6b6b
    style L1 fill:#51cf66
    style L2 fill:#51cf66
    style L3 fill:#51cf66
```

---

## Linux vs Windows Comparison

### Comprehensive Comparison Table

| Feature | Linux | Windows |
|---------|-------|---------|
| **Cost** | Free (Open Source) | Paid (Commercial License) |
| **Source Code** | Open (anyone can view/modify) | Closed (proprietary) |
| **Security** | Very secure (no antivirus needed) | Requires antivirus |
| **Virus Susceptibility** | Very low | High |
| **Updates** | User-controlled | Forced automatic updates |
| **Customization** | Highly customizable | Limited customization |
| **Command Line** | Powerful shell (Bash, Zsh) | PowerShell, CMD (less powerful) |
| **Server Usage** | 90%+ of servers | ~8% of servers |
| **Desktop Usage** | ~2-3% | ~75% |
| **Gaming Support** | Limited (improving) | Excellent |
| **Software Availability** | Many free alternatives | More commercial software |
| **System Requirements** | Low (runs on old hardware) | Higher requirements |
| **Learning Curve** | Steeper initially | Easier for beginners |

### Visual Comparison

```mermaid
flowchart TB
    subgraph Linux_Pros["Linux Advantages"]
        L1[üÜì Free]
        L2[üîí Secure]
        L3[‚ö° Fast]
        L4[üîß Customizable]
        L5[üìä Server Standard]
    end
    
    subgraph Windows_Pros["Windows Advantages"]
        W1[üéÆ Gaming]
        W2[üì± User Friendly]
        W3[üíº Office Software]
        W4[üñ•Ô∏è Desktop Apps]
        W5[ü§ù Vendor Support]
    end
    
    style L1 fill:#51cf66
    style L2 fill:#51cf66
    style L3 fill:#51cf66
    style L4 fill:#51cf66
    style L5 fill:#51cf66
    style W1 fill:#228be6
    style W2 fill:#228be6
    style W3 fill:#228be6
    style W4 fill:#228be6
    style W5 fill:#228be6
```

---

## Linux vs Unix

### Key Differences

| Aspect | Linux | Unix |
|--------|-------|------|
| **Cost** | Free (Open Source) | Paid (Commercial) |
| **Source Code** | Open | Closed (proprietary) |
| **Development** | Community-driven | Vendor-driven |
| **Examples** | Ubuntu, CentOS, Fedora | macOS, Solaris, AIX, HP-UX |
| **Hardware** | Runs on any hardware | Often hardware-specific |
| **License** | GPL (GNU Public License) | Proprietary licenses |

### Historical Context

```mermaid
timeline
    title Evolution of Unix-like Operating Systems
    1969 : Unix created at AT&T Bell Labs
    1983 : GNU Project started by Richard Stallman
    1991 : Linux Kernel created by Linus Torvalds
    1993 : First Linux distributions (Slackware, Debian)
    2004 : Ubuntu released
    Present : Linux dominates servers and cloud
```

### The Relationship

```mermaid
flowchart TD
    Unix[Unix<br/>1969 - AT&T Bell Labs<br/>Commercial, Closed Source]
    
    Unix --> Inspiration
    
    subgraph Inspiration["Inspired By Unix"]
        GNU[GNU Project<br/>1983 - Free Software]
        Linux[Linux Kernel<br/>1991 - Linus Torvalds]
    end
    
    GNU --> Combine
    Linux --> Combine
    
    Combine[GNU/Linux<br/>Complete Free OS]
    
    Combine --> Distros
    
    subgraph Distros["Linux Distributions"]
        Ubuntu
        CentOS
        Fedora
        Debian
        RedHat
    end
    
    style Unix fill:#ff6b6b
    style Combine fill:#51cf66
```

### Quick Summary

> **Unix** is the commercial, paid predecessor that inspired Linux.
> **Linux** is the free, open-source alternative that has largely replaced Unix in most use cases.

---

## How to Install Linux

There are multiple ways to get Linux running on your system:

### Installation Methods Overview

```mermaid
flowchart TD
    Start[Want to Use Linux?]
    
    Start --> Method1[1Ô∏è‚É£ Dual Boot]
    Start --> Method2[2Ô∏è‚É£ WSL<br/>Windows Subsystem for Linux]
    Start --> Method3[3Ô∏è‚É£ Virtual Machine<br/>VirtualBox/VMware]
    Start --> Method4[4Ô∏è‚É£ Cloud VM<br/>AWS EC2/Azure/GCP]
    Start --> Method5[5Ô∏è‚É£ Vagrant]
    Start --> Method6[6Ô∏è‚É£ Docker Container]
    
    Method1 --> Native[Native Performance<br/>Full Installation]
    Method2 --> Easy[Easy for Windows Users<br/>Integrated]
    Method3 --> Safe[Safe Testing<br/>Isolated Environment]
    Method4 --> Cloud[No Hardware Needed<br/>Production-like]
    Method5 --> Automated[Automated Setup<br/>HashiCorp Tool]
    Method6 --> Container[Lightweight<br/>Quick to Start]
    
    style Method4 fill:#51cf66
```

### Detailed Methods Comparison

| Method | Pros | Cons | Best For |
|--------|------|------|----------|
| **Dual Boot** | Full performance, native experience | Risk of data loss, complex setup | Full-time Linux users |
| **WSL (Windows Subsystem for Linux)** | Easy setup, integrated with Windows | Windows 10/11 only, some limitations | Windows users wanting Linux terminal |
| **VirtualBox/VMware** | Safe, isolated, easy snapshots | Slower performance, resource intensive | Learning and testing |
| **AWS EC2/Cloud** | No local resources needed, production-like | Requires internet, may have costs | DevOps practice, production |
| **Vagrant** | Automated setup, reproducible | Learning curve | Development environments |
| **Docker** | Lightweight, fast | Not full OS experience | Containerized applications |

### Recommended Method for DevOps Learning

> **Best Choice for DevOps:** AWS EC2 (Free Tier)
> - Mimics production environment
> - Free for 12 months (within limits)
> - Practice cloud skills simultaneously
> - No local resource usage

### Popular Linux Distributions

```mermaid
mindmap
  root((Linux Distributions))
    Debian Family
      Debian
      Ubuntu
      Linux Mint
    Red Hat Family
      RHEL
      CentOS
      Fedora
    SUSE Family
      openSUSE
      SLES
    Arch Family
      Arch Linux
      Manjaro
    Specialized
      Kali Linux (Security)
      Alpine (Containers)
```

| Distribution | Use Case | Package Manager |
|-------------|----------|-----------------|
| **Ubuntu** | General purpose, beginners, servers | apt |
| **CentOS/Rocky Linux** | Enterprise servers | yum/dnf |
| **Debian** | Stable servers | apt |
| **Fedora** | Latest features, developers | dnf |
| **Kali Linux** | Security/Penetration testing | apt |
| **Alpine** | Containers (lightweight) | apk |

---

## Linux Core Components

### The Three Pillars of Linux

```mermaid
flowchart TD
    subgraph Core["Linux Core Components"]
        K[ü´Ä Kernel<br/>The Heart]
        S[üêö Shell<br/>The Interface]
        B[üöÄ Boot Loader<br/>The Starter]
    end
    
    K --> |"Manages hardware,<br/>processes, memory"| Hardware[Hardware]
    S --> |"Communicates<br/>user commands"| K
    B --> |"Loads kernel<br/>at startup"| K
    
    User[üë§ User] --> S
    
    style K fill:#ff6b6b
    style S fill:#51cf66
    style B fill:#228be6
```

---

### 1. Kernel (‡§ï‡§∞‡•ç‡§®‡§≤)

#### Definition

> **Kernel** is the core component of the Linux operating system. It acts as a bridge between applications and hardware, managing system resources like CPU, memory, and devices.

#### Key Responsibilities

| Function | Description |
|----------|-------------|
| **Process Management** | Creates, schedules, and terminates processes |
| **Memory Management** | Allocates and deallocates memory |
| **Device Management** | Communicates with hardware devices |
| **File System Management** | Handles file operations |
| **Security** | Enforces access controls |

#### Kernel Architecture

```mermaid
flowchart TB
    subgraph User_Space["User Space"]
        Apps[Applications]
        Shell[Shell/Terminal]
    end
    
    subgraph Kernel_Space["Kernel Space"]
        SC[System Calls Interface]
        PM[Process Management]
        MM[Memory Management]
        FS[File System]
        DD[Device Drivers]
    end
    
    subgraph Hardware_Layer["Hardware"]
        CPU[CPU]
        RAM[RAM]
        Disk[Hard Disk]
        NIC[Network Card]
    end
    
    Apps --> Shell
    Shell --> SC
    SC --> PM
    SC --> MM
    SC --> FS
    SC --> DD
    PM --> CPU
    MM --> RAM
    FS --> Disk
    DD --> NIC
    
    style Kernel_Space fill:#ffeb3b,color:#000
```

---

### 2. Shell (‡§∂‡•á‡§≤)

#### Definition

> **Shell** is a command-line interface that allows users to interact with the kernel. It interprets user commands and translates them into kernel-understandable instructions.

#### Simple Analogy

Think of Shell as a **translator**:
- You speak English (Shell commands)
- Kernel speaks C/Assembly (low-level code)
- Shell translates between you and the kernel

#### How Shell Works

```mermaid
sequenceDiagram
    participant User as üë§ User
    participant Shell as üêö Shell
    participant Kernel as ü´Ä Kernel
    participant Hardware as üíæ Hardware
    
    User->>Shell: mkdir my_folder
    Shell->>Kernel: System call: Create directory
    Kernel->>Hardware: Write to disk
    Hardware-->>Kernel: Success
    Kernel-->>Shell: Operation complete
    Shell-->>User: (Folder created)
```

#### Types of Shells

| Shell | Full Name | Features |
|-------|-----------|----------|
| **bash** | Bourne Again Shell | Most common, default on many systems |
| **zsh** | Z Shell | Feature-rich, used in macOS |
| **sh** | Bourne Shell | Original Unix shell, minimal |
| **fish** | Friendly Interactive Shell | User-friendly, auto-suggestions |
| **csh** | C Shell | C-like syntax |

#### Common Shell Commands (Preview)

| Command | Purpose | Example |
|---------|---------|---------|
| `mkdir` | Create directory | `mkdir my_folder` |
| `cd` | Change directory | `cd /home/user` |
| `ls` | List files | `ls -la` |
| `pwd` | Print working directory | `pwd` |
| `rm` | Remove files/directories | `rm file.txt` |

---

### 3. Boot Loader (‡§¨‡•Ç‡§ü ‡§≤‡•ã‡§°‡§∞)

#### Definition

> **Boot Loader** is a program that runs first when you power on your computer. It loads the operating system kernel into memory and starts it.

#### Full Form of GRUB

```
G.R.U.B = Grand Unified Boot Loader
```

#### Boot Process Flow

```mermaid
flowchart LR
    subgraph Boot_Process["Linux Boot Process"]
        direction LR
        P[üîå Power On] --> BIOS[BIOS/UEFI<br/>Hardware Check]
        BIOS --> GRUB[GRUB<br/>Boot Loader]
        GRUB --> Kernel[Kernel<br/>Loads into RAM]
        Kernel --> Init[Init/Systemd<br/>First Process PID=1]
        Init --> Services[Services<br/>Start]
        Services --> Login[Login<br/>Prompt]
    end
    
    style GRUB fill:#51cf66
    style Kernel fill:#ff6b6b
```

#### Boot Process Explained

| Step | Component | Description |
|------|-----------|-------------|
| 1 | **Power On** | Electricity flows to motherboard |
| 2 | **BIOS/UEFI** | Basic Input/Output System checks hardware |
| 3 | **GRUB** | Boot loader finds and loads kernel |
| 4 | **Kernel** | Core OS loads into RAM |
| 5 | **Init/Systemd** | First process (PID 1) starts |
| 6 | **Services** | System services begin |
| 7 | **Login** | User can now log in |

#### Key Point About First Process

> The first process started by the boot loader has **Process ID (PID) = 1**. This is always the init or systemd process.

```bash
# Verify first process
ps -p 1
# Shows: PID 1 is systemd (or init)
```

---

## Linux System Architecture

### Layered Architecture

```mermaid
flowchart TB
    subgraph Layer1["Layer 1: Applications"]
        A1[Terminal]
        A2[Browser]
        A3[Text Editor]
        A4[Custom Apps]
    end
    
    subgraph Layer2["Layer 2: Shell"]
        SH[Shell<br/>Bash/Zsh/Fish]
    end
    
    subgraph Layer3["Layer 3: Kernel"]
        K[Linux Kernel]
    end
    
    subgraph Layer4["Layer 4: Hardware"]
        H1[CPU]
        H2[RAM]
        H3[Disk]
        H4[Network]
    end
    
    A1 --> SH
    A2 --> SH
    A3 --> SH
    A4 --> SH
    SH --> K
    K --> H1
    K --> H2
    K --> H3
    K --> H4
    
    style Layer1 fill:#e3f2fd
    style Layer2 fill:#c8e6c9
    style Layer3 fill:#fff9c4
    style Layer4 fill:#ffcdd2
```

### Circular Architecture View

```mermaid
flowchart TD
    subgraph Architecture["Linux System Architecture"]
        direction TB
        
        subgraph Outer["Outer Layer: Applications/Utilities"]
            Apps[Applications<br/>Terminal, Browser, etc.]
        end
        
        subgraph Middle["Middle Layer: Shell"]
            Shell[Shell<br/>Command Interpreter]
        end
        
        subgraph Inner["Inner Layer: Kernel"]
            Kernel[Kernel<br/>Core of OS]
        end
        
        subgraph Core["Core: Hardware"]
            HW[Hardware<br/>CPU, RAM, Disk]
        end
        
        Apps --> Shell
        Shell --> Kernel
        Kernel --> HW
    end
```

### Architecture Summary Table

| Layer | Component | Function | Examples |
|-------|-----------|----------|----------|
| **Outermost** | Applications | User programs | Firefox, vim, terminal |
| **Middle** | Shell | Command interface | Bash, Zsh, Fish |
| **Inner** | Kernel | OS core | Linux kernel |
| **Core** | Hardware | Physical devices | CPU, RAM, SSD |

---

## Linux File System Hierarchy

### The Root Directory

> In Linux, **everything starts from root (`/`)**. This is the top-level directory from which all other directories branch out.

```bash
cd /    # Go to root directory
```

### File System Structure

```mermaid
flowchart TD
    Root["/"]
    
    Root --> home["/home<br/>User home directories"]
    Root --> usr["/usr<br/>User programs"]
    Root --> bin["/bin<br/>Essential binaries"]
    Root --> etc["/etc<br/>Configuration files"]
    Root --> var["/var<br/>Variable data (logs)"]
    Root --> tmp["/tmp<br/>Temporary files"]
    Root --> boot["/boot<br/>Boot loader files"]
    Root --> dev["/dev<br/>Device files"]
    Root --> opt["/opt<br/>Optional software"]
    Root --> root["/root<br/>Root user home"]
    
    home --> user1["/home/shubham"]
    home --> user2["/home/john"]
    
    var --> logs["/var/log<br/>Log files"]
    var --> cache["/var/cache"]
    
    style Root fill:#ff6b6b
```

### Directory Purposes

| Directory | Purpose | Examples |
|-----------|---------|----------|
| `/` | Root directory (top level) | Everything starts here |
| `/home` | User home directories | `/home/shubham`, `/home/john` |
| `/usr` | User programs and data | `/usr/bin`, `/usr/lib` |
| `/bin` | Essential command binaries | `ls`, `cp`, `mv` |
| `/etc` | System configuration files | `/etc/passwd`, `/etc/hosts` |
| `/var` | Variable data (changes frequently) | Logs, caches, mail |
| `/var/log` | System and application logs | `syslog`, `auth.log` |
| `/tmp` | Temporary files (cleared on reboot) | Temp downloads |
| `/boot` | Boot loader and kernel files | `grub`, `vmlinuz` |
| `/dev` | Device files | `sda`, `tty`, `null` |
| `/opt` | Optional/third-party software | Manual installations |
| `/root` | Root user's home directory | Separate from `/home` |

### Navigating the File System

```bash
# Go to root
cd /

# Go to home directory
cd ~
# or
cd /home/username

# Go to logs
cd /var/log

# List directory contents
ls -la

# Print current directory
pwd
```

---

## Hardware Information Commands

### Essential Commands for Hardware Info

| Command | Purpose | What it Shows |
|---------|---------|---------------|
| `top` | Real-time process viewer | CPU, memory, running processes |
| `htop` | Enhanced process viewer | Better visualization of `top` |
| `free -h` | Memory usage | RAM usage (total, used, free) |
| `df -h` | Disk space | Hard disk usage |
| `lscpu` | CPU information | CPU architecture, cores, speed |
| `lsblk` | Block devices | Disks and partitions |
| `uname -a` | System information | Kernel version, hostname |

### Command Examples and Output

```bash
# CPU and Process Information
top
# Shows: PID, USER, CPU%, MEM%, running/sleeping processes

# Memory Information
free -h
# Output example:
#               total        used        free      shared  buff/cache   available
# Mem:           15Gi       8.0Gi       2.0Gi       500Mi       5.0Gi       6.5Gi
# Swap:          2.0Gi       0.0Gi       2.0Gi

# Disk Space
df -h
# Output example:
# Filesystem      Size  Used Avail Use% Mounted on
# /dev/sda1       100G   45G   55G  45% /

# System Information
uname -a
# Output: Linux hostname 5.15.0 #1 SMP x86_64 GNU/Linux
```

### Understanding `top` Command Output

```mermaid
flowchart TD
    subgraph Top_Output["top Command Information"]
        direction LR
        
        subgraph Summary["Summary Section"]
            S1[Total Processes]
            S2[Running Processes]
            S3[Sleeping Processes]
            S4[Stopped Processes]
            S5[Zombie Processes]
        end
        
        subgraph Process_List["Process List"]
            P1[PID - Process ID]
            P2[USER - Owner]
            P3[CPU% - CPU Usage]
            P4[MEM% - Memory Usage]
            P5[STATE - Running/Sleeping]
        end
    end
```

---

## Process States in Linux

### Definition

> **Process** is a program in execution. Each process has a unique identifier called **PID (Process ID)**.

### Process States

```mermaid
stateDiagram-v2
    [*] --> Created: Process Created
    Created --> Ready: Admitted
    Ready --> Running: Scheduler Picks
    Running --> Ready: Interrupt
    Running --> Waiting: I/O Request
    Waiting --> Ready: I/O Complete
    Running --> Terminated: Exit
    Running --> Zombie: Parent not waiting
    Terminated --> [*]
    Zombie --> [*]: Parent collects status
    
    note right of Running: Currently executing<br/>on CPU
    note right of Waiting: Waiting for I/O<br/>or event
    note right of Zombie: Completed but<br/>not cleaned up
```

### Process States Table

| State | Symbol | Description |
|-------|--------|-------------|
| **Running (R)** | R | Currently executing on CPU |
| **Sleeping (S)** | S | Waiting for an event (interruptible) |
| **Uninterruptible Sleep (D)** | D | Waiting for I/O (cannot be interrupted) |
| **Stopped (T)** | T | Stopped by signal (SIGSTOP) |
| **Zombie (Z)** | Z | Completed but parent hasn't collected status |
| **Dead (X)** | X | Should never be seen (instant transition) |

### Process States Explained

| State | Real-World Analogy |
|-------|-------------------|
| **Running** | Employee actively working |
| **Sleeping** | Employee waiting for meeting to start |
| **Stopped** | Employee on break (can resume) |
| **Zombie** | Employee finished work but hasn't reported to manager |
| **Dead** | Employee has left the company |

### Key Process Commands

```bash
# View all processes with states
ps aux

# View process tree
pstree

# Real-time process monitoring
top

# Kill a process
kill PID
kill -9 PID    # Force kill

# View process ID of first process (should be 1)
ps -p 1
```

### Important Note About PID 1

> The first process started by the kernel has **PID = 1**. This is typically `init` or `systemd`, and it's the ancestor of all other processes.

---

## Remote Access Tools

As a DevOps engineer, you'll need to connect to remote servers. Here are the main tools:

### Remote Access Methods

```mermaid
flowchart LR
    subgraph Local["Your Computer"]
        You[üë§ You]
    end
    
    subgraph Methods["Connection Methods"]
        SSH[SSH<br/>Secure Shell]
        RDP[RDP<br/>Remote Desktop]
        VNC[VNC<br/>Virtual Network Computing]
        Tools[Other Tools<br/>AnyDesk, TeamViewer]
    end
    
    subgraph Remote["Remote Server"]
        Server[üñ•Ô∏è Linux Server]
    end
    
    You --> SSH
    You --> RDP
    You --> VNC
    You --> Tools
    
    SSH --> Server
    RDP --> Server
    VNC --> Server
    Tools --> Server
    
    style SSH fill:#51cf66
```

### Comparison Table

| Tool | Protocol | Best For | GUI Support |
|------|----------|----------|-------------|
| **SSH** | SSH | Linux servers, secure access | No (command line) |
| **RDP** | RDP | Windows servers | Yes |
| **VNC** | VNC | Any OS with GUI | Yes |
| **AnyDesk** | Proprietary | Quick remote access | Yes |
| **TeamViewer** | Proprietary | Support/assistance | Yes |

### SSH (Secure Shell)

> **SSH** is the primary method DevOps engineers use to connect to remote Linux servers.

```bash
# Basic SSH connection
ssh username@server-ip

# SSH with specific port
ssh -p 22 username@server-ip

# SSH with key file
ssh -i keyfile.pem username@server-ip
```

---

## Setting Up Linux on AWS EC2

### Step-by-Step Guide

```mermaid
flowchart TD
    A[1. Create AWS Account] --> B[2. Go to EC2 Dashboard]
    B --> C[3. Click 'Launch Instance']
    C --> D[4. Name: 'linux-for-devops']
    D --> E[5. Select AMI: Ubuntu]
    E --> F[6. Instance Type: t2.micro<br/>Free Tier Eligible]
    F --> G[7. Create Key Pair<br/>Download .pem file]
    G --> H[8. Launch Instance]
    H --> I[9. Wait for 'Running' status]
    I --> J[10. Connect via SSH]
    
    style E fill:#51cf66
    style F fill:#51cf66
```

### Detailed Steps

| Step | Action | Important Notes |
|------|--------|-----------------|
| 1 | Go to [aws.amazon.com](https://aws.amazon.com) | Credit/Debit card needed |
| 2 | Search for "EC2" | Elastic Compute Cloud |
| 3 | Click "Launch Instance" | Creates a new virtual server |
| 4 | Name your instance | Example: "linux-for-devops" |
| 5 | Choose AMI | Select **Ubuntu** (Free Tier Eligible) |
| 6 | Choose Instance Type | Select **t2.micro** (Free Tier Eligible) |
| 7 | Create Key Pair | Download the .pem file - **DON'T LOSE IT!** |
| 8 | Launch Instance | Click launch |
| 9 | Wait for Status | Should show "Running" |
| 10 | Connect | Use SSH to connect |

### EC2 Connection Commands

```bash
# Change key file permissions (required)
chmod 400 your-key.pem

# Connect to EC2 instance
ssh -i your-key.pem ubuntu@your-ec2-public-ip

# Example:
ssh -i linux-devops.pem ubuntu@54.123.45.67
```

### Free Tier Limits (Important!)

| Resource | Free Tier Limit |
|----------|-----------------|
| EC2 Hours | 750 hours/month (t2.micro) |
| Storage | 30 GB EBS |
| Duration | 12 months from signup |
| Data Transfer | 15 GB outbound |

> ‚ö†Ô∏è **Warning:** Going beyond free tier limits will incur charges. Always stop instances when not in use!

---

## Key Interview Questions

### Common DevOps Linux Interview Questions

| # | Question | Key Points for Answer |
|---|----------|----------------------|
| 1 | How does the internet work? | Fiber optic cables, data centers, ISPs, DNS |
| 2 | What is a server? | Computer that serves information to clients |
| 3 | Difference between server and client? | Server serves, client requests |
| 4 | Difference between web server and application server? | Static vs dynamic content |
| 5 | What is Linux? | Free, open-source OS kernel by Linus Torvalds |
| 6 | Why do 90%+ servers use Linux? | Security, stability, free, no antivirus needed |
| 7 | Difference between Linux and Unix? | Linux is free/open-source; Unix is commercial |
| 8 | What is a kernel? | Core of OS, manages hardware and processes |
| 9 | What is a shell? | Interface between user and kernel |
| 10 | What is GRUB? | Grand Unified Boot Loader - starts the OS |
| 11 | What is PID 1? | First process (init/systemd), started by boot loader |
| 12 | Name process states in Linux | Running, Sleeping, Stopped, Zombie, Dead |
| 13 | What is the root directory? | `/` - top-level directory in Linux |
| 14 | Commands for hardware info? | `top`, `free -h`, `df -h`, `lscpu` |

### Quick Answer Templates

**Q: How does the internet work?**
> The internet works through fiber optic cables laid under the ocean that connect data centers worldwide. When you request a website, your ISP routes the request through these cables to the server hosting the website, which then sends the response back through the same infrastructure.

**Q: What is the difference between a web server and application server?**
> A **web server** serves static content like HTML, CSS, images, and JavaScript files (example: Nginx, Apache). An **application server** runs application logic and serves dynamic content that requires computation (example: Django, Node.js applications).

**Q: What is the kernel in Linux?**
> The kernel is the core component of Linux that acts as a bridge between applications and hardware. It manages system resources including process scheduling, memory allocation, device communication, and file system operations.

---

## Summary

### Key Takeaways from Day 1

```mermaid
mindmap
  root((Day 1 Summary))
    Internet
      Fiber Optic Cables
      Data Centers
      ISPs
      DNS Servers
    Servers
      Types: Web, App, DB, Email, File
      Client-Server Model
      Static vs Dynamic Content
    Linux
      Free & Open Source
      90%+ Server Market
      Created by Linus Torvalds 1991
    Architecture
      Kernel: Core/Heart
      Shell: User Interface
      Boot Loader: GRUB Starts System
    File System
      Starts from Root /
      /home, /var, /etc, /bin
    Processes
      States: Running, Sleeping, Zombie
      PID 1 is First Process
    Practice
      AWS EC2 Free Tier
      Ubuntu t2.micro
```

### What's Next (Day 2 Preview)

- Linux Basic Commands
- File and Directory Operations
- User Management
- Permissions
- Package Management
- And more hands-on practice!

---

## Quick Reference Card

### Essential Commands

| Command | Purpose |
|---------|---------|
| `cd /` | Go to root directory |
| `cd ~` | Go to home directory |
| `ls -la` | List all files with details |
| `pwd` | Print current directory |
| `top` | View running processes |
| `free -h` | View memory usage |
| `df -h` | View disk usage |
| `ssh user@ip` | Connect to remote server |

### Architecture Flow

```
User ‚Üí Applications ‚Üí Shell ‚Üí Kernel ‚Üí Hardware
```

### Boot Sequence

```
Power On ‚Üí BIOS/UEFI ‚Üí GRUB ‚Üí Kernel ‚Üí Systemd (PID 1) ‚Üí Services ‚Üí Login
```

---

*üìù These notes cover Linux for DevOps Day 1: Introduction and Fundamentals*

*üé• Based on the comprehensive video tutorial covering everything from internet basics to setting up your first Linux server on AWS*
